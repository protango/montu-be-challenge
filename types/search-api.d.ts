/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/search/{versionNumber}/additionalData.{ext}": {
    /** Additional Data */
    get: {
      parameters: {
        query: {
          /**
           * @description Comma separated list of geometry UUIDs, previously retrieved from an Search API request.
           * @example 00004631-3400-3c00-0000-0000673c4d2e,00004631-3400-3c00-0000-0000673c42fe
           */
          geometries: string;
          /** @description Defines the precision of the geometries. */
          geometriesZoom?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22;
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /** @description Expected response format. */
          ext: "json";
        };
      };
      responses: {
        /** @description OK: additional data were retrieved and the body of the response contains requested data. */
        200: {
          content: never;
        };
        /** @description Bad request: one or more parameters(i.e. geometries, ext) were incorrectly specified. */
        400: {
          content: never;
        };
        /**
         * @description Permission, capacity, or authentication issues:
         *   - Forbidden
         *   - Not authorized
         *   - Account inactive
         *   - Account over queries per second limit
         *   - Account over rate limit
         *   - Rate limit exceeded
         */
        403: {
          content: never;
        };
        /** @description Not Found: the requested resource could not be found, but it may be available again in the future. */
        404: {
          content: never;
        };
        /** @description Method Not Allowed: the client used a HTTP method other than GET. */
        405: {
          content: never;
        };
        /** @description Request timeout. */
        408: {
          content: never;
        };
        /** @description Requested uri is too long. */
        414: {
          content: never;
        };
        /** @description An error occurred while processing the request. Please try again later. */
        500: {
          content: never;
        };
        /** @description Internal network connectivity issue. */
        502: {
          content: never;
        };
        /** @description Service currently unavailable. */
        503: {
          content: never;
        };
        /** @description Internal network connectivity issue or a request that has taken too long to complete. */
        504: {
          content: never;
        };
        /** @description Service not found. */
        596: {
          content: never;
        };
      };
    };
  };
  "/search/{versionNumber}/cS/{category}.{ext}": {
    /**
     * Low Bandwidth Category Search
     * @deprecated
     */
    get: {
      parameters: {
        query?: {
          typeahead?: components["parameters"]["typeahead"];
          limit?: components["parameters"]["limit"];
          ofs?: components["parameters"]["ofs"];
          countrySet?: components["parameters"]["countrySet"];
          lat?: components["parameters"]["lat"];
          lon?: components["parameters"]["lon"];
          radius?: components["parameters"]["radius"];
          topLeft?: components["parameters"]["topLeft"];
          btmRight?: components["parameters"]["btmRight"];
          language?: components["parameters"]["language"];
          idxSet?: components["parameters"]["idxSet"];
          view?: components["parameters"]["view"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string. Must be properly URL encoded.
           * @example pizza
           */
          category: string;
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/categorySearch/{query}.{ext}": {
    /** Category Search */
    get: {
      parameters: {
        query?: {
          typeahead?: components["parameters"]["typeahead"];
          limit?: components["parameters"]["limit"];
          ofs?: components["parameters"]["ofs"];
          countrySet?: components["parameters"]["countrySet"];
          lat?: components["parameters"]["lat"];
          lon?: components["parameters"]["lon"];
          radius?: components["parameters"]["radius"];
          topLeft?: components["parameters"]["topLeft"];
          btmRight?: components["parameters"]["btmRight"];
          language?: components["parameters"]["language"];
          extendedPostalCodesFor?: components["parameters"]["extendedPostalCodesFor"];
          categorySet?: components["parameters"]["categorySet"];
          brandSet?: components["parameters"]["brandSet"];
          connectorSet?: components["parameters"]["connectorSet"];
          minPowerKW?: components["parameters"]["minPowerKW"];
          maxPowerKW?: components["parameters"]["maxPowerKW"];
          fuelSet?: components["parameters"]["fuelSet"];
          view?: components["parameters"]["view"];
          openingHours?: components["parameters"]["openingHours"];
          mapcodes?: components["parameters"]["mapcodes"];
          timeZone?: components["parameters"]["timeZone"];
          relatedPois?: components["parameters"]["relatedPois"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string. Must be properly URL encoded.
           * @example pizza
           */
          query: string;
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/geometryFilter.{ext}": {
    /** Geometry Filter */
    get: {
      parameters: {
        query: {
          /**
           * @description List of geometries to filter by. Available types are CIRCLE (with the radius expressed in meters) and POLYGON.
           * @example [{"type":"CIRCLE", "position":"40.80558, -73.96548", "radius":100}, {"type":"POLYGON", "vertices":["37.7524152343544, -122.43576049804686", "37.70660472542312, -122.43301391601562", "37.712059855877314, -122.36434936523438", "37.75350561243041, -122.37396240234374"]}]
           */
          geometryList: string;
          /**
           * @description List of POIs to filter. The only required attribute of a POI is position, everything else is optional and will be echoed back when passed in.
           * @example [{"poi":{"name":"S Restaurant Toms"},"address":{"freeformAddress":"2880 Broadway, New York, NY 10025"},"position":{"lat":40.80558,"lon":-73.96548}},{"poi":{"name":"Yasha Raman Corporation"},"address":{"freeformAddress":"940 Amsterdam Ave, New York, NY 10025"},"position":{"lat":40.80076,"lon":-73.96556}}]
           */
          poiList: string;
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
    /** Geometry Filter */
    post: {
      parameters: {
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          ext: components["parameters"]["ext"];
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            geometryList?: {
                position?: string;
                radius?: number;
                type?: string;
                vertices?: string[];
              }[];
            poiList?: {
                address?: {
                  freeformAddress?: string;
                };
                poi?: {
                  name?: string;
                };
                position?: {
                  /** Format: float */
                  lat?: number;
                  /** Format: float */
                  lon?: number;
                };
              }[];
          };
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/geometrySearch/{query}.{ext}": {
    /** Geometry Search */
    get: {
      parameters: {
        query: {
          /**
           * @description List of geometries to filter by. Available types are CIRCLE (with the radius expressed in meters) and POLYGON.
           * @example [{"type":"POLYGON", "vertices":["37.7524152343544, -122.43576049804686", "37.70660472542312, -122.43301391601562", "37.712059855877314, -122.36434936523438", "37.75350561243041, -122.37396240234374"]}, {"type":"CIRCLE", "position":"37.71205, -121.36434", "radius":6000}, {"type":"CIRCLE", "position":"37.31205, -121.36434", "radius":1000}]
           */
          geometryList: string;
          limit?: components["parameters"]["limit"];
          language?: components["parameters"]["language"];
          extendedPostalCodesFor?: components["parameters"]["extendedPostalCodesFor"];
          idxSet?: components["parameters"]["idxSet"];
          categorySet?: components["parameters"]["categorySet"];
          brandSet?: components["parameters"]["brandSet"];
          connectorSet?: components["parameters"]["connectorSet"];
          minPowerKW?: components["parameters"]["minPowerKW"];
          maxPowerKW?: components["parameters"]["maxPowerKW"];
          fuelSet?: components["parameters"]["fuelSet"];
          view?: components["parameters"]["view"];
          openingHours?: components["parameters"]["openingHours"];
          timeZone?: components["parameters"]["timeZone"];
          mapcodes?: components["parameters"]["mapcodes"];
          relatedPois?: components["parameters"]["relatedPois"];
          entityTypeSet?: components["parameters"]["entityTypeSet"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string. Must be properly URL encoded.
           * @example pizza
           */
          query: string;
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
    /** Geometry Search */
    post: {
      parameters: {
        query?: {
          limit?: components["parameters"]["limit"];
          language?: components["parameters"]["language"];
          extendedPostalCodesFor?: components["parameters"]["extendedPostalCodesFor"];
          idxSet?: components["parameters"]["idxSet"];
          categorySet?: components["parameters"]["categorySet"];
          brandSet?: components["parameters"]["brandSet"];
          connectorSet?: components["parameters"]["connectorSet"];
          minPowerKW?: components["parameters"]["minPowerKW"];
          maxPowerKW?: components["parameters"]["maxPowerKW"];
          fuelSet?: components["parameters"]["fuelSet"];
          view?: components["parameters"]["view"];
          openingHours?: components["parameters"]["openingHours"];
          timeZone?: components["parameters"]["timeZone"];
          mapcodes?: components["parameters"]["mapcodes"];
          relatedPois?: components["parameters"]["relatedPois"];
          entityTypeSet?: components["parameters"]["entityTypeSet"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string. Must be properly URL encoded.
           * @example pizza
           */
          query: string;
          ext: components["parameters"]["ext"];
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            geometryList?: {
                position?: string;
                radius?: number;
                type?: string;
                vertices?: string[];
              }[];
          };
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/nearbySearch/.{ext}": {
    /** Nearby Search */
    get: {
      parameters: {
        query: {
          /**
           * @description Latitude where results should be biased.
           * NOTE: supplying a lat/lon without a radius will return search results biased to that point.
           * @example 37.337
           */
          lat: number;
          /**
           * @description Longitude where results should be biased
           * NOTE: supplying a lat/lon without a radius will return search results biased to that point.
           * @example -121.89
           */
          lon: number;
          limit?: components["parameters"]["limit"];
          ofs?: components["parameters"]["ofs"];
          countrySet?: components["parameters"]["countrySet"];
          /** @description If radius and position are set, the results will be constrained to the defined area. The radius parameter is specified in meters. */
          radius?: number;
          /**
           * @deprecated
           * @description Top left position of the bounding box. This is specified as a comma separated string composed of lat., lon.
           */
          topLeft?: string;
          /**
           * @deprecated
           * @description Bottom right position of the bounding box. This is specified as a comma separated string composed of lat., lon.
           */
          btmRight?: string;
          language?: components["parameters"]["language"];
          extendedPostalCodesFor?: components["parameters"]["extendedPostalCodesFor"];
          categorySet?: components["parameters"]["categorySet"];
          brandSet?: components["parameters"]["brandSet"];
          connectorSet?: components["parameters"]["connectorSet"];
          minPowerKW?: components["parameters"]["minPowerKW"];
          maxPowerKW?: components["parameters"]["maxPowerKW"];
          fuelSet?: components["parameters"]["fuelSet"];
          view?: components["parameters"]["view"];
          openingHours?: components["parameters"]["openingHours"];
          mapcodes?: components["parameters"]["mapcodes"];
          timeZone?: components["parameters"]["timeZone"];
          relatedPois?: components["parameters"]["relatedPois"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/poiCategories.{ext}": {
    /** POI Categories */
    get: {
      parameters: {
        query?: {
          language?: components["parameters"]["language"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /** @description Expected response format. */
          ext: "json" | "jsonp" | "js" | "xml";
        };
      };
      responses: {
        /** @description OK: The search successfully returned result. */
        200: {
          content: never;
        };
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/poiSearch/{query}.{ext}": {
    /** Points of Interest Search */
    get: {
      parameters: {
        query?: {
          typeahead?: components["parameters"]["typeahead"];
          limit?: components["parameters"]["limit"];
          ofs?: components["parameters"]["ofs"];
          countrySet?: components["parameters"]["countrySet"];
          lat?: components["parameters"]["lat"];
          lon?: components["parameters"]["lon"];
          radius?: components["parameters"]["radius"];
          topLeft?: components["parameters"]["topLeft"];
          btmRight?: components["parameters"]["btmRight"];
          language?: components["parameters"]["language"];
          extendedPostalCodesFor?: components["parameters"]["extendedPostalCodesFor"];
          categorySet?: components["parameters"]["categorySet"];
          brandSet?: components["parameters"]["brandSet"];
          connectorSet?: components["parameters"]["connectorSet"];
          minPowerKW?: components["parameters"]["minPowerKW"];
          maxPowerKW?: components["parameters"]["maxPowerKW"];
          fuelSet?: components["parameters"]["fuelSet"];
          view?: components["parameters"]["view"];
          openingHours?: components["parameters"]["openingHours"];
          mapcodes?: components["parameters"]["mapcodes"];
          timeZone?: components["parameters"]["timeZone"];
          relatedPois?: components["parameters"]["relatedPois"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string. Must be properly URL encoded.
           * @example pizza
           */
          query: string;
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/routedFilter/{position}/{heading}.{ext}": {
    /**
     * Routed Filter
     * @deprecated
     */
    get: {
      parameters: {
        query: {
          /**
           * @description List of POIs to filter. The only required attribute of a POI is position, everything else is optional and will be echoed back when passed in.
           * @example [{"poi":{"name":"Cleaire Advanced Emission Controls"},"address":{"freeformAddress":"7220 Trade St, San Diego, CA 92121"},"position":{"lat":"37.83274","lon":"-122.27631"}}]
           */
          poiList: string;
          routingTimeout?: components["parameters"]["routingTimeout"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          position: components["parameters"]["position"];
          /**
           * @description The directional heading in degrees, usually similar to the course along a road segment. Entered in degrees, measured clockwise from north (so north is 0, east is 90, etc.)
           * @example -15.6
           */
          heading: number;
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
    /**
     * Routed Filter
     * @deprecated
     */
    post: {
      parameters: {
        query?: {
          routingTimeout?: components["parameters"]["routingTimeout"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          position: components["parameters"]["position"];
          /**
           * @description The directional heading in degrees, usually similar to the course along a road segment. Entered in degrees, measured clockwise from north (so north is 0, east is 90, etc.)
           * @example 90
           */
          heading: number;
          ext: components["parameters"]["ext"];
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            poiList?: {
                address?: {
                  freeformAddress?: string;
                };
                poi?: {
                  name?: string;
                };
                position?: {
                  /** Format: float */
                  lat?: number;
                  /** Format: float */
                  lon?: number;
                };
              }[];
          };
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/routedSearch/{query}/{position}/{heading}.{ext}": {
    /**
     * Routed Search
     * @deprecated
     */
    get: {
      parameters: {
        query?: {
          typeahead?: components["parameters"]["typeahead"];
          limit?: components["parameters"]["limit"];
          /** @description Multiplies the limit by N to gather more candidate POIs, which will then be sorted by drive distance, returning only the top candidates according to the limit. */
          multiplier?: number;
          routingTimeout?: components["parameters"]["routingTimeout"];
          language?: components["parameters"]["language"];
          extendedPostalCodesFor?: components["parameters"]["extendedPostalCodesFor"];
          idxSet?: components["parameters"]["idxSet"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string. Must be properly URL encoded.
           * @example gas
           */
          query: string;
          position: components["parameters"]["position"];
          /**
           * @description The directional heading in degrees, usually similar to the course along a road segment. Entered in degrees, measured clockwise from north (so north is 0, east is 90, etc.)
           * @example 90
           */
          heading: number;
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/s/{query}.{ext}": {
    /**
     * Low bandwith Search
     * @deprecated
     */
    get: {
      parameters: {
        query?: {
          typeahead?: components["parameters"]["typeahead"];
          limit?: components["parameters"]["limit"];
          ofs?: components["parameters"]["ofs"];
          countrySet?: components["parameters"]["countrySet"];
          lat?: components["parameters"]["lat"];
          lon?: components["parameters"]["lon"];
          radius?: components["parameters"]["radius"];
          topLeft?: components["parameters"]["topLeft"];
          btmRight?: components["parameters"]["btmRight"];
          language?: components["parameters"]["language"];
          idxSet?: components["parameters"]["idxSet"];
          view?: components["parameters"]["view"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string. Must be properly URL encoded.
           * @example pizza
           */
          query: string;
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/search/{query}.{ext}": {
    /** Fuzzy Search */
    get: {
      parameters: {
        query?: {
          typeahead?: components["parameters"]["typeahead"];
          limit?: components["parameters"]["limit"];
          ofs?: components["parameters"]["ofs"];
          countrySet?: components["parameters"]["countrySet"];
          lat?: components["parameters"]["lat"];
          lon?: components["parameters"]["lon"];
          radius?: components["parameters"]["radius"];
          topLeft?: components["parameters"]["topLeft"];
          btmRight?: components["parameters"]["btmRight"];
          language?: components["parameters"]["language"];
          extendedPostalCodesFor?: components["parameters"]["extendedPostalCodesFor"];
          minFuzzyLevel?: components["parameters"]["minFuzzyLevel"];
          maxFuzzyLevel?: components["parameters"]["maxFuzzyLevel"];
          idxSet?: components["parameters"]["idxSet"];
          categorySet?: components["parameters"]["categorySet"];
          brandSet?: components["parameters"]["brandSet"];
          connectorSet?: components["parameters"]["connectorSet"];
          minPowerKW?: components["parameters"]["minPowerKW"];
          maxPowerKW?: components["parameters"]["maxPowerKW"];
          fuelSet?: components["parameters"]["fuelSet"];
          view?: components["parameters"]["view"];
          openingHours?: components["parameters"]["openingHours"];
          timeZone?: components["parameters"]["timeZone"];
          mapcodes?: components["parameters"]["mapcodes"];
          relatedPois?: components["parameters"]["relatedPois"];
          entityTypeSet?: components["parameters"]["entityTypeSet"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string.
           *   - Must be properly URL encoded.
           *   - A user can provide latitude and longitude coordinates or mapcodes directly in the query.
           *   - Details can be found in the <a href="/search-api/search-api-documentation-search/fuzzy-search#coordinates">Coordinates in query</a> documentation section and in the <a href="/search-api/search-api-documentation-search/fuzzy-search#mapcodesQuery">Mapcodes in query</a> documentation sections.
           * @example pizza
           */
          query: string;
          ext: components["parameters"]["ext"];
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
  "/search/{versionNumber}/searchAlongRoute/{query}.{ext}": {
    /** Along Route Search */
    post: {
      parameters: {
        query: {
          /**
           * @description Maximum detour time
           * @example 600
           */
          maxDetourTime: number;
          typeahead?: components["parameters"]["typeahead"];
          limit?: components["parameters"]["limit"];
          categorySet?: components["parameters"]["categorySet"];
          brandSet?: components["parameters"]["brandSet"];
          connectorSet?: components["parameters"]["connectorSet"];
          minPowerKW?: components["parameters"]["minPowerKW"];
          maxPowerKW?: components["parameters"]["maxPowerKW"];
          fuelSet?: components["parameters"]["fuelSet"];
          view?: components["parameters"]["view"];
          /** @description Parameter which turns on a calculation of the distance between the start of the route and the starting point of the detour to a POI. */
          detourOffset?: boolean;
          /** @description Parameter which provides the possibility to sort returned results. */
          sortBy?: "detourTime" | "detourDistance" | "detourOffset";
          openingHours?: components["parameters"]["openingHours"];
          /** @description Enables the spreading of returned results evenly along the route. */
          spreadingMode?: "auto";
          mapcodes?: components["parameters"]["mapcodes"];
          timeZone?: components["parameters"]["timeZone"];
          relatedPois?: components["parameters"]["relatedPois"];
        };
        path: {
          versionNumber: components["parameters"]["versionNumber"];
          /**
           * @description Query string. Must be properly URL encoded.
           * @example pizza
           */
          query: string;
          ext: components["parameters"]["ext"];
        };
      };
      requestBody?: {
        content: {
          "application/json": {
            route?: {
              points?: {
                  /** Format: float */
                  lat?: number;
                  /** Format: float */
                  lon?: number;
                }[];
            };
          };
        };
      };
      responses: {
        200: components["responses"]["200"];
        400: components["responses"]["400"];
        403: components["responses"]["403"];
        404: components["responses"]["404596"];
        405: components["responses"]["405"];
        429: components["responses"]["429"];
        596: components["responses"]["404596"];
        "5XX": components["responses"]["5xx"];
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: never;
  responses: {
    /** @description OK: the search successfully returned zero or more results. */
    200: {
      content: never;
    };
    /** @description Bad Request: one or more parameters were incorrectly specified. */
    400: {
      content: never;
    };
    /**
     * @description Forbidden: possible causes include:
     *   - Service requires SSL
     *   - Not authorized
     *   - Rate or volume limit exceeded
     *   - Unknown referrer
     */
    403: {
      content: never;
    };
    /** @description Method Not Allowed: the HTTP method (GET, POST, etc) is not supported for this request. */
    405: {
      content: never;
    };
    /** @description Too Many Requests: Rate or volume limit exceeded */
    429: {
      content: never;
    };
    /** @description Not Found: the HTTP request method (GET, POST, etc) or path is incorrect. */
    404596: {
      content: never;
    };
    /** @description An error occurred while processing the request. Please try again later. */
    "5xx": {
      content: never;
    };
  };
  parameters: {
    /** @description The format of new lines in the formatted address. */
    allowFreeformNewLine?: boolean;
    /** @description A comma-separated list of brand names which could be used to restrict the result to Points Of Interest of specific brands. */
    brandSet?: string;
    /** @description Bottom right position of the bounding box. This is specified as a comma separated string composed of lat., lon. */
    btmRight?: string;
    /**
     * @description A comma-separated list of categories which could be used to restrict the result to Points Of Interest of specific categories. The list of categories can be discovered using the <a href="/search-api/search-api-documentation/poi-categories" target="_blank">POI Categories endpoint</a>.
     * Note: In the following "example:", "7315" indicates a "restaurant".
     * @example 7315
     */
    categorySet?: string;
    /** @description A comma-separated list of connector types which could be used to restrict the result to Points Of Interest of type Electric Vehicle Station supporting specific connector types. <a href="/search-api/search-api-documentation/supported-connector-types" target="_blank">List of supported connector types</a>. */
    connectorSet?: string;
    /**
     * @description 2 or 3 letter country code (e.g.: FR, ES).
     * @example NL
     */
    countryCode: string;
    /** @description The county for the structured address. */
    countrySecondarySubdivision?: string;
    /** @description Comma separated string of country codes. This will limit the search to the specified countries. */
    countrySet?: string;
    /** @description The state or province for the structured address. */
    countrySubdivision?: string;
    /** @description The named area for the structured address. */
    countryTertiarySubdivision?: string;
    /** @description The cross street name for the structured address. */
    crossStreet?: string;
    /** @description A comma-separated list of entity types which can be used to restrict the result to the Geography result of a specific entity type. If entityTypeSet is specified, only a Geography result with a proper entity type will be returned. */
    entityTypeSet?: "Country" | "CountrySubdivision" | "CountrySecondarySubdivision" | "CountryTertiarySubdivision" | "Municipality" | "MunicipalitySubdivision" | "MunicipalitySecondarySubdivision" | "Neighbourhood" | "PostalCodeArea";
    /**
     * @description Expected response format.
     * @example json
     */
    ext: "json" | "jsonp" | "js" | "xml";
    /**
     * @description Indexes for which extended postal codes should be included in the results. Available indexes are:
     *   - <b>Addr</b> = Address ranges
     *   - <b>Geo</b> = Geographies
     *   - <b>PAD</b> = Point Addresses
     *   - <b>POI</b> = Points of Interest
     *   - <b>Str</b> = Streets
     *   - <b>XStr</b> = Cross Streets (intersections)
     */
    extendedPostalCodesFor?: string;
    /** @description A comma-separated list of fuel types which could be used to restrict the result to the Points Of Interest of specific fuels. If fuelSet is specified, the query can remain empty. Only POIs with a proper fuel type will be returned. */
    fuelSet?: ("Petrol" | "LPG" | "Diesel" | "Biodiesel" | "DieselForCommercialVehicles" | "E85" | "LNG" | "CNG" | "Hydrogen" | "AdBlue")[];
    /**
     * @description A comma separated list of indexes which should be utilized for the search. Item order does not matter. Available indexes are:
     *   - <b>Addr</b> = Address range interpolation (when there is no PAD)
     *   - <b>Geo</b> = Geographies
     *   - <b>PAD</b> = Point Addresses
     *   - <b>POI</b> = Points of interest
     *   - <b>Str</b> = Streets
     *   - <b>Xstr</b> = Cross Streets (intersections)
     */
    idxSet?: string;
    /** @description Language in which search results should be returned. Should be one of <a href="/search-api/search-api-documentation/supported-languages">supported IETF language tags</a>, case insensitive. */
    language?: string;
    /**
     * @description Latitude where results should be biased.
     * NOTE: supplying a lat/lon without a radius will return search results biased to that point.
     * @example 37.337
     */
    lat?: number;
    /** @description Maximum number of search results that will be returned. */
    limit?: number;
    /**
     * @description Longitude where results should be biased.
     * NOTE: supplying a lat/lon without a radius will return search results biased to that point.
     * @example -121.89
     */
    lon?: number;
    /** @description Enables the return of a comma-separated mapcodes list. Can also filter the response to only show selected mapcode types. See <a href="/search-api/search-api-documentation-search/fuzzy-search#mapcodes" target="_blank">Mapcodes in the response</a>. */
    mapcodes?: string;
    /** @description Maximum fuzziness level to be used. */
    maxFuzzyLevel?: number;
    /** @description An optional parameter which could be used to restrict the result to the Points Of Interest of type Electric Vehicle Station supporting at least one connector with a specific maximum value of power in kilowatts (closed interval - with that value). */
    maxPowerKW?: number;
    /** @description Minimum fuzziness level to be used. */
    minFuzzyLevel?: number;
    /** @description An optional parameter which could be used to restrict the result to the Points Of Interest of type Electric Vehicle Station supporting at least one connector with a specific minimal value of power in kilowatts (closed interval - with that value). */
    minPowerKW?: number;
    /**
     * @description The municipality (city/town) for the structured address.
     * @example Amsterdam
     */
    municipality?: string;
    /** @description The municipality subdivision (sub city) for the structured address. */
    municipalitySubdivision?: string;
    /** @description The municipality secondary subdivision (sub sub city) for the structured address. */
    municipalitySecondarySubdivision?: string;
    /** @description Starting offset of the returned results within the full result set. */
    ofs?: number;
    /** @description List of opening hours for a POI. */
    openingHours?: "nextSevenDays";
    /**
     * @description This is specified as a comma separated string composed of lat., lon.
     * @example 37.8328,-122.27669
     */
    position: string;
    /** @description The zip code or postal code for the structured address. */
    postalCode?: string;
    /** @description If radius <b>and</b> position are set, the results will be constrained to the defined area. The radius parameter is specified in meters. */
    radius?: number;
    /** @description An optional parameter that provides the possibility to return related Points Of Interest. */
    relatedPois?: "off" | "child" | "parent" | "all";
    /** @description Only return results that arrive from routing engine within this time limit. */
    routingTimeout?: number;
    /**
     * @deprecated
     * @description If the "storeResult" flag is set, the query will be interpreted as a stored geocode and it will be billed according to the terms of use.
     */
    storeResult?: boolean;
    /** @description The street name for the structured address. */
    streetName?: string;
    /** @description The street number for the structured address. */
    streetNumber?: string;
    /** @description Used to indicate the mode in which the timeZone object should be returned. */
    timeZone?: "iana";
    /** @description Top left position of the bounding box. This is specified as a comma separated string composed of lat., lon. */
    topLeft?: string;
    /** @description If the "typeahead" flag is set, the query will be interpreted as a partial input and the search will enter <b>predictive</b> mode. */
    typeahead?: boolean;
    /** @description Service version number. The current value is 2. */
    versionNumber: 2;
    /** @description Geopolitical View. */
    view?: "Unified" | "IL" | "IN" | "MA" | "PK" | "RU" | "TR" | "CN";
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export type operations = Record<string, never>;
